{
    "sourceFile": "otel_telemetry_manager.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1752193086172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752193092594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -302,8 +302,9 @@\n             trace.get_tracer_provider().force_flush()\n         \n         if self.config.enable_metrics:\n             # Metrics are automatically flushed by the reader\n+            pass\n \n # Factory function for easy creation\n def create_telemetry_manager(\n     service_name: str = \"autotel-service\",\n"
                }
            ],
            "date": 1752193086172,
            "name": "Commit-0",
            "content": "#!/usr/bin/env python3\n\"\"\"\nOpenTelemetry Telemetry Manager with LinkML Schema Integration\nEliminates hardcoded strings by using LinkML schema for all telemetry operations\n\"\"\"\n\nimport json\nimport time\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Optional, Union\nfrom pathlib import Path\nfrom dataclasses import dataclass, field\n\n# OpenTelemetry imports\nfrom opentelemetry import trace, metrics\nfrom opentelemetry.trace import Status, StatusCode\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import ConsoleSpanExporter, BatchSpanProcessor\nfrom opentelemetry.sdk.metrics import MeterProvider\nfrom opentelemetry.sdk.metrics.export import ConsoleMetricExporter, PeriodicExportingMetricReader\nfrom opentelemetry.sdk.resources import Resource\n\n# LinkML imports\nfrom linkml_runtime.utils.schemaview import SchemaView\nfrom linkml_runtime.dumpers import yaml_dumper\nfrom linkml_runtime.loaders import yaml_loader\n\n@dataclass\nclass TelemetryConfig:\n    \"\"\"Configuration for telemetry operations\"\"\"\n    service_name: str = \"autotel-service\"\n    service_version: str = \"1.0.0\"\n    enable_tracing: bool = True\n    enable_metrics: bool = True\n    schema_path: Optional[str] = None\n\nclass OTELTelemetryManager:\n    \"\"\"\n    OpenTelemetry Telemetry Manager using LinkML schema\n    Eliminates hardcoded strings by using schema-driven telemetry\n    \"\"\"\n    \n    def __init__(self, config: TelemetryConfig):\n        \"\"\"Initialize the telemetry manager with LinkML schema\"\"\"\n        self.config = config\n        self.schema_view: Optional[SchemaView] = None\n        self.tracer: Optional[trace.Tracer] = None\n        self.meter: Optional[metrics.Meter] = None\n        \n        # Load LinkML schema for telemetry\n        self._load_telemetry_schema()\n        \n        # Initialize OpenTelemetry\n        self._initialize_otel()\n        \n        # Create metrics from schema\n        self._create_metrics_from_schema()\n    \n    def _load_telemetry_schema(self) -> None:\n        \"\"\"Load the OTEL traces LinkML schema\"\"\"\n        if self.config.schema_path:\n            schema_path = Path(self.config.schema_path)\n        else:\n            # Default to the schema in the same directory\n            schema_path = Path(__file__).parent / \"otel_traces_schema.yaml\"\n        \n        if not schema_path.exists():\n            raise FileNotFoundError(f\"Telemetry schema not found: {schema_path}\")\n        \n        self.schema_view = SchemaView(str(schema_path))\n        \n        # Validate schema has required classes\n        required_classes = [\"Span\", \"LinkMLOperation\", \"ValidationResult\"]\n        for class_name in required_classes:\n            if not self.schema_view.get_class(class_name):\n                raise ValueError(f\"Required class '{class_name}' not found in telemetry schema\")\n    \n    def _initialize_otel(self) -> None:\n        \"\"\"Initialize OpenTelemetry with resource information\"\"\"\n        # Create resource with service information\n        resource = Resource.create({\n            \"service.name\": self.config.service_name,\n            \"service.version\": self.config.service_version\n        })\n        \n        if self.config.enable_tracing:\n            # Configure tracing\n            trace_provider = TracerProvider(resource=resource)\n            trace_provider.add_span_processor(BatchSpanProcessor(ConsoleSpanExporter()))\n            trace.set_tracer_provider(trace_provider)\n            self.tracer = trace.get_tracer(self.config.service_name)\n        \n        if self.config.enable_metrics:\n            # Configure metrics\n            metric_reader = PeriodicExportingMetricReader(ConsoleMetricExporter())\n            metric_provider = MeterProvider(resource=resource, metric_readers=[metric_reader])\n            metrics.set_meter_provider(metric_provider)\n            self.meter = metrics.get_meter(self.config.service_name)\n    \n    def _create_metrics_from_schema(self) -> None:\n        \"\"\"Create metrics based on the LinkML schema definitions\"\"\"\n        if not self.meter or not self.schema_view:\n            return\n        \n        # Get metric definitions from schema\n        metric_class = self.schema_view.get_class(\"Metric\")\n        if not metric_class:\n            return\n        \n        # Create counters for LinkML operations\n        self.linkml_operations_counter = self.meter.create_counter(\n            name=\"linkml_operations_total\",\n            description=\"Total number of LinkML operations performed\"\n        )\n        \n        # Create histogram for operation durations\n        self.operation_duration_histogram = self.meter.create_histogram(\n            name=\"linkml_operation_duration_seconds\",\n            description=\"Duration of LinkML operations in seconds\"\n        )\n        \n        # Create counter for validation operations\n        self.validation_operations_counter = self.meter.create_counter(\n            name=\"validation_operations_total\",\n            description=\"Total number of validation operations\"\n        )\n    \n    def get_operation_type_enum(self) -> List[str]:\n        \"\"\"Get valid operation types from the LinkML schema\"\"\"\n        if not self.schema_view:\n            return []\n        \n        operation_enum = self.schema_view.get_enum(\"LinkMLOperationType\")\n        if operation_enum:\n            return list(operation_enum.permissible_values.keys())\n        return []\n    \n    def get_validation_type_enum(self) -> List[str]:\n        \"\"\"Get valid validation types from the LinkML schema\"\"\"\n        if not self.schema_view:\n            return []\n        \n        validation_enum = self.schema_view.get_enum(\"ValidationType\")\n        if validation_enum:\n            return list(validation_enum.permissible_values.keys())\n        return []\n    \n    def create_span_attributes(self, operation_type: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Create span attributes using LinkML schema validation\"\"\"\n        if not self.schema_view:\n            return kwargs\n        \n        # Validate operation type against schema\n        valid_operations = self.get_operation_type_enum()\n        if operation_type not in valid_operations:\n            raise ValueError(f\"Invalid operation type '{operation_type}'. Valid types: {valid_operations}\")\n        \n        # Get span attributes from schema\n        span_class = self.schema_view.get_class(\"Span\")\n        if not span_class:\n            return kwargs\n        \n        # Create validated attributes\n        attributes = {\"operation_type\": operation_type}\n        \n        # Add schema-validated attributes\n        for key, value in kwargs.items():\n            # Check if this is a valid span attribute\n            if key in span_class.attributes or key in self.schema_view.all_slots():\n                attributes[key] = value\n        \n        return attributes\n    \n    def start_span(self, name: str, operation_type: str, **kwargs) -> trace.Span:\n        \"\"\"Start a span with schema-validated attributes\"\"\"\n        if not self.tracer:\n            raise RuntimeError(\"Tracing not enabled\")\n        \n        attributes = self.create_span_attributes(operation_type, **kwargs)\n        return self.tracer.start_as_current_span(name, attributes=attributes)\n    \n    def record_metric(self, metric_name: str, value: Union[int, float], **attributes) -> None:\n        \"\"\"Record a metric with schema validation\"\"\"\n        if not self.meter:\n            raise RuntimeError(\"Metrics not enabled\")\n        \n        # Validate metric attributes against schema\n        validated_attributes = {}\n        for key, val in attributes.items():\n            if key in self.schema_view.all_slots():\n                validated_attributes[key] = val\n        \n        if metric_name == \"linkml_operations_total\":\n            self.linkml_operations_counter.add(value, validated_attributes)\n        elif metric_name == \"validation_operations_total\":\n            self.validation_operations_counter.add(value, validated_attributes)\n        elif metric_name == \"operation_duration_seconds\":\n            self.operation_duration_histogram.record(value, validated_attributes)\n    \n    def validate_span_data(self, span_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate span data against LinkML schema\"\"\"\n        if not self.schema_view:\n            return span_data\n        \n        # Get span class definition\n        span_class = self.schema_view.get_class(\"Span\")\n        if not span_class:\n            return span_data\n        \n        # Validate required attributes\n        validated_data = {}\n        for attr_name, attr_def in span_class.attributes.items():\n            if attr_name in span_data:\n                # Basic type validation\n                if attr_def.range == \"string\" and not isinstance(span_data[attr_name], str):\n                    span_data[attr_name] = str(span_data[attr_name])\n                elif attr_def.range == \"integer\" and not isinstance(span_data[attr_name], int):\n                    try:\n                        span_data[attr_name] = int(span_data[attr_name])\n                    except (ValueError, TypeError):\n                        continue\n                elif attr_def.range == \"float\" and not isinstance(span_data[attr_name], float):\n                    try:\n                        span_data[attr_name] = float(span_data[attr_name])\n                    except (ValueError, TypeError):\n                        continue\n                \n                validated_data[attr_name] = span_data[attr_name]\n        \n        return validated_data\n    \n    def create_linkml_operation(self, operation_type: str, **kwargs) -> Dict[str, Any]:\n        \"\"\"Create a LinkML operation record using schema\"\"\"\n        if not self.schema_view:\n            return {\"operation_type\": operation_type, **kwargs}\n        \n        # Get LinkMLOperation class definition\n        operation_class = self.schema_view.get_class(\"LinkMLOperation\")\n        if not operation_class:\n            return {\"operation_type\": operation_type, **kwargs}\n        \n        # Validate operation type\n        valid_operations = self.get_operation_type_enum()\n        if operation_type not in valid_operations:\n            raise ValueError(f\"Invalid operation type '{operation_type}'. Valid types: {valid_operations}\")\n        \n        # Create operation record with schema validation\n        operation_record = {\"operation_type\": operation_type}\n        \n        for key, value in kwargs.items():\n            if key in operation_class.attributes:\n                operation_record[key] = value\n        \n        return operation_record\n    \n    def create_validation_result(self, validation_type: str, passed: bool, **kwargs) -> Dict[str, Any]:\n        \"\"\"Create a validation result using schema\"\"\"\n        if not self.schema_view:\n            return {\"validation_type\": validation_type, \"passed\": passed, **kwargs}\n        \n        # Validate validation type\n        valid_types = self.get_validation_type_enum()\n        if validation_type not in valid_types:\n            raise ValueError(f\"Invalid validation type '{validation_type}'. Valid types: {valid_types}\")\n        \n        # Get ValidationResult class definition\n        result_class = self.schema_view.get_class(\"ValidationResult\")\n        if not result_class:\n            return {\"validation_type\": validation_type, \"passed\": passed, **kwargs}\n        \n        # Create validation result with schema validation\n        validation_result = {\n            \"validation_type\": validation_type,\n            \"passed\": passed\n        }\n        \n        for key, value in kwargs.items():\n            if key in result_class.attributes:\n                validation_result[key] = value\n        \n        return validation_result\n    \n    def export_schema_metadata(self) -> Dict[str, Any]:\n        \"\"\"Export schema metadata for telemetry validation\"\"\"\n        if not self.schema_view:\n            return {}\n        \n        return {\n            \"schema_id\": self.schema_view.schema.id,\n            \"schema_name\": self.schema_view.schema.name,\n            \"schema_version\": self.schema_view.schema.version,\n            \"classes_count\": len(self.schema_view.all_classes()),\n            \"enums_count\": len(self.schema_view.all_enums()),\n            \"slots_count\": len(self.schema_view.all_slots()),\n            \"operation_types\": self.get_operation_type_enum(),\n            \"validation_types\": self.get_validation_type_enum()\n        }\n    \n    def force_flush(self) -> None:\n        \"\"\"Force flush all telemetry data\"\"\"\n        if self.config.enable_tracing:\n            trace.get_tracer_provider().force_flush()\n        \n        if self.config.enable_metrics:\n            # Metrics are automatically flushed by the reader\n\n# Factory function for easy creation\ndef create_telemetry_manager(\n    service_name: str = \"autotel-service\",\n    service_version: str = \"1.0.0\",\n    schema_path: Optional[str] = None,\n    enable_tracing: bool = True,\n    enable_metrics: bool = True\n) -> OTELTelemetryManager:\n    \"\"\"Create a telemetry manager with the specified configuration\"\"\"\n    config = TelemetryConfig(\n        service_name=service_name,\n        service_version=service_version,\n        schema_path=schema_path,\n        enable_tracing=enable_tracing,\n        enable_metrics=enable_metrics\n    )\n    return OTELTelemetryManager(config) "
        }
    ]
}