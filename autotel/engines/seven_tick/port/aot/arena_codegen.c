#include "arena_codegen.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <assert.h>

// Default buffer size for code generation
#define DEFAULT_BUFFER_SIZE 4096
#define MAX_IDENTIFIER_LENGTH 64

// Create a new code generation context
arena_codegen_ctx_t* arena_codegen_create(FILE* output, const arena_codegen_config_t* config) {
    if (!output || !config) {
        return NULL;
    }
    
    arena_codegen_ctx_t* ctx = calloc(1, sizeof(arena_codegen_ctx_t));
    if (!ctx) {
        return NULL;
    }
    
    ctx->output = output;
    ctx->config = *config;
    ctx->template_type = ARENA_TEMPLATE_SIMPLE;
    ctx->indent_level = 0;
    ctx->buffer_size = DEFAULT_BUFFER_SIZE;
    ctx->buffer_pos = 0;
    
    ctx->buffer = malloc(ctx->buffer_size);
    if (!ctx->buffer) {
        free(ctx);
        return NULL;
    }
    
    return ctx;
}

// Destroy code generation context
void arena_codegen_destroy(arena_codegen_ctx_t* ctx) {
    if (!ctx) return;
    
    if (ctx->zones) {
        free(ctx->zones);
    }
    if (ctx->buffer) {
        free(ctx->buffer);
    }
    free(ctx);
}

// Set template type
int arena_codegen_set_template(arena_codegen_ctx_t* ctx, arena_template_type_t type) {
    if (!ctx) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    ctx->template_type = type;
    return ARENA_CODEGEN_OK;
}

// Add a zone configuration
int arena_codegen_add_zone(arena_codegen_ctx_t* ctx, const arena_zone_config_t* zone) {
    if (!ctx || !zone) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    if (arena_codegen_validate_zone(zone) != ARENA_CODEGEN_OK) {
        return ARENA_CODEGEN_ERROR_INVALID_ZONE;
    }
    
    // Resize zones array
    ctx->zones = realloc(ctx->zones, (ctx->zone_count + 1) * sizeof(arena_zone_config_t));
    if (!ctx->zones) {
        return ARENA_CODEGEN_ERROR_NULL_POINTER;
    }
    
    ctx->zones[ctx->zone_count] = *zone;
    ctx->zone_count++;
    
    return ARENA_CODEGEN_OK;
}

// Emit formatted code with current indentation
void arena_codegen_emit(arena_codegen_ctx_t* ctx, const char* format, ...) {
    if (!ctx || !format) return;
    
    // Add indentation
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
    
    va_list args;
    va_start(args, format);
    vfprintf(ctx->output, format, args);
    va_end(args);
}

// Emit formatted code with newline
void arena_codegen_emit_line(arena_codegen_ctx_t* ctx, const char* format, ...) {
    if (!ctx || !format) return;
    
    // Add indentation
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
    
    va_list args;
    va_start(args, format);
    vfprintf(ctx->output, format, args);
    va_end(args);
    
    fprintf(ctx->output, "\n");
}

// Increase indentation level
void arena_codegen_indent(arena_codegen_ctx_t* ctx) {
    if (ctx) ctx->indent_level++;
}

// Decrease indentation level
void arena_codegen_dedent(arena_codegen_ctx_t* ctx) {
    if (ctx && ctx->indent_level > 0) ctx->indent_level--;
}

// Generate header guards and includes
int arena_codegen_generate_header(arena_codegen_ctx_t* ctx) {
    if (!ctx) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    if (ctx->config.include_guards) {
        arena_codegen_emit_line(ctx, "#ifndef %s_ARENA_H", ctx->config.arena_name ? ctx->config.arena_name : "GENERATED");
        arena_codegen_emit_line(ctx, "#define %s_ARENA_H", ctx->config.arena_name ? ctx->config.arena_name : "GENERATED");
        arena_codegen_emit_line(ctx, "");
    }
    
    arena_codegen_emit_line(ctx, "// Generated by ARENAC AOT Code Generator");
    arena_codegen_emit_line(ctx, "// Total arena size: %zu bytes (%.2f MB)", 
                           ctx->config.total_size, 
                           (double)ctx->config.total_size / (1024.0 * 1024.0));
    arena_codegen_emit_line(ctx, "");
    
    arena_codegen_emit_line(ctx, "#include <stddef.h>");
    arena_codegen_emit_line(ctx, "#include <stdint.h>");
    arena_codegen_emit_line(ctx, "");
    
    return ARENA_CODEGEN_OK;
}

// Generate arena declarations
int arena_codegen_generate_declarations(arena_codegen_ctx_t* ctx) {
    if (!ctx) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    const char* arena_name = ctx->config.arena_name ? ctx->config.arena_name : "global_arena";
    const char* type_name = ctx->config.type_name ? ctx->config.type_name : "arena_t";
    
    // Generate arena type definition
    arena_codegen_emit_line(ctx, "typedef struct {");
    arena_codegen_indent(ctx);
    arena_codegen_emit_line(ctx, "char* beg;");
    arena_codegen_emit_line(ctx, "char* end;");
    arena_codegen_emit_line(ctx, "char* pos;");
    if (ctx->config.include_debug_info) {
        arena_codegen_emit_line(ctx, "size_t allocated;");
        arena_codegen_emit_line(ctx, "size_t peak_usage;");
        arena_codegen_emit_line(ctx, "const char* name;");
    }
    arena_codegen_dedent(ctx);
    arena_codegen_emit_line(ctx, "} %s;", type_name);
    arena_codegen_emit_line(ctx, "");
    
    // Generate static storage declaration
    if (ctx->config.use_static_storage) {
        arena_codegen_emit_line(ctx, "// Static arena storage (%zu bytes)", ctx->config.total_size);
        arena_codegen_emit_line(ctx, "static char %s_storage[%zu] __attribute__((aligned(%zu)));", 
                               arena_name, ctx->config.total_size, ctx->config.alignment);
        arena_codegen_emit_line(ctx, "");
        
        arena_codegen_emit_line(ctx, "// Arena instance");
        arena_codegen_emit_line(ctx, "static %s %s = {", type_name, arena_name);
        arena_codegen_indent(ctx);
        arena_codegen_emit_line(ctx, ".beg = %s_storage,", arena_name);
        arena_codegen_emit_line(ctx, ".end = %s_storage + sizeof(%s_storage),", arena_name, arena_name);
        arena_codegen_emit_line(ctx, ".pos = %s_storage", arena_name);
        if (ctx->config.include_debug_info) {
            arena_codegen_emit_line(ctx, ",.allocated = 0");
            arena_codegen_emit_line(ctx, ",.peak_usage = 0");
            arena_codegen_emit_line(ctx, ",.name = \"%s\"", arena_name);
        }
        arena_codegen_dedent(ctx);
        arena_codegen_emit_line(ctx, "};");
    } else {
        arena_codegen_emit_line(ctx, "// Arena instance (requires initialization)");
        arena_codegen_emit_line(ctx, "extern %s %s;", type_name, arena_name);
    }
    
    arena_codegen_emit_line(ctx, "");
    
    return ARENA_CODEGEN_OK;
}

// Generate initialization code
int arena_codegen_generate_initialization(arena_codegen_ctx_t* ctx) {
    if (!ctx) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    const char* arena_name = ctx->config.arena_name ? ctx->config.arena_name : "global_arena";
    const char* type_name = ctx->config.type_name ? ctx->config.type_name : "arena_t";
    
    if (!ctx->config.use_static_storage) {
        arena_codegen_emit_line(ctx, "// Arena initialization function");
        arena_codegen_emit_line(ctx, "static inline int %s_init(%s* arena, void* memory, size_t size) {", arena_name, type_name);
        arena_codegen_indent(ctx);
        arena_codegen_emit_line(ctx, "if (!arena || !memory || size == 0) return -1;");
        arena_codegen_emit_line(ctx, "");
        arena_codegen_emit_line(ctx, "arena->beg = (char*)memory;");
        arena_codegen_emit_line(ctx, "arena->end = (char*)memory + size;");
        arena_codegen_emit_line(ctx, "arena->pos = (char*)memory;");
        if (ctx->config.include_debug_info) {
            arena_codegen_emit_line(ctx, "arena->allocated = 0;");
            arena_codegen_emit_line(ctx, "arena->peak_usage = 0;");
            arena_codegen_emit_line(ctx, "arena->name = \"%s\";", arena_name);
        }
        arena_codegen_emit_line(ctx, "return 0;");
        arena_codegen_dedent(ctx);
        arena_codegen_emit_line(ctx, "}");
        arena_codegen_emit_line(ctx, "");
    }
    
    return ARENA_CODEGEN_OK;
}

// Generate accessor functions
int arena_codegen_generate_accessors(arena_codegen_ctx_t* ctx) {
    if (!ctx) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    const char* arena_name = ctx->config.arena_name ? ctx->config.arena_name : "global_arena";
    const char* type_name = ctx->config.type_name ? ctx->config.type_name : "arena_t";
    
    // Allocation function
    arena_codegen_emit_line(ctx, "// Arena allocation function");
    arena_codegen_emit_line(ctx, "static inline void* %s_alloc(%s* arena, size_t size, size_t align) {", arena_name, type_name);
    arena_codegen_indent(ctx);
    arena_codegen_emit_line(ctx, "if (!arena || size == 0) return NULL;");
    arena_codegen_emit_line(ctx, "");
    arena_codegen_emit_line(ctx, "// Align current position");
    arena_codegen_emit_line(ctx, "uintptr_t pos = (uintptr_t)arena->pos;");
    arena_codegen_emit_line(ctx, "uintptr_t aligned = (pos + align - 1) & ~(align - 1);");
    arena_codegen_emit_line(ctx, "char* result = (char*)aligned;");
    arena_codegen_emit_line(ctx, "");
    arena_codegen_emit_line(ctx, "// Check bounds");
    arena_codegen_emit_line(ctx, "if (result + size > arena->end) return NULL;");
    arena_codegen_emit_line(ctx, "");
    arena_codegen_emit_line(ctx, "arena->pos = result + size;");
    if (ctx->config.include_debug_info) {
        arena_codegen_emit_line(ctx, "arena->allocated += size;");
        arena_codegen_emit_line(ctx, "size_t current_usage = arena->pos - arena->beg;");
        arena_codegen_emit_line(ctx, "if (current_usage > arena->peak_usage) arena->peak_usage = current_usage;");
    }
    arena_codegen_emit_line(ctx, "return result;");
    arena_codegen_dedent(ctx);
    arena_codegen_emit_line(ctx, "}");
    arena_codegen_emit_line(ctx, "");
    
    // Reset function
    arena_codegen_emit_line(ctx, "// Arena reset function");
    arena_codegen_emit_line(ctx, "static inline void %s_reset(%s* arena) {", arena_name, type_name);
    arena_codegen_indent(ctx);
    arena_codegen_emit_line(ctx, "if (!arena) return;");
    arena_codegen_emit_line(ctx, "arena->pos = arena->beg;");
    if (ctx->config.include_debug_info) {
        arena_codegen_emit_line(ctx, "arena->allocated = 0;");
    }
    arena_codegen_dedent(ctx);
    arena_codegen_emit_line(ctx, "}");
    arena_codegen_emit_line(ctx, "");
    
    // Available space function
    arena_codegen_emit_line(ctx, "// Available space function");
    arena_codegen_emit_line(ctx, "static inline size_t %s_available(%s* arena) {", arena_name, type_name);
    arena_codegen_indent(ctx);
    arena_codegen_emit_line(ctx, "if (!arena) return 0;");
    arena_codegen_emit_line(ctx, "return arena->end - arena->pos;");
    arena_codegen_dedent(ctx);
    arena_codegen_emit_line(ctx, "}");
    arena_codegen_emit_line(ctx, "");
    
    if (ctx->config.include_debug_info) {
        // Usage statistics
        arena_codegen_emit_line(ctx, "// Usage statistics");
        arena_codegen_emit_line(ctx, "static inline size_t %s_used(%s* arena) {", arena_name, type_name);
        arena_codegen_indent(ctx);
        arena_codegen_emit_line(ctx, "if (!arena) return 0;");
        arena_codegen_emit_line(ctx, "return arena->pos - arena->beg;");
        arena_codegen_dedent(ctx);
        arena_codegen_emit_line(ctx, "}");
        arena_codegen_emit_line(ctx, "");
        
        arena_codegen_emit_line(ctx, "static inline size_t %s_peak_usage(%s* arena) {", arena_name, type_name);
        arena_codegen_indent(ctx);
        arena_codegen_emit_line(ctx, "if (!arena) return 0;");
        arena_codegen_emit_line(ctx, "return arena->peak_usage;");
        arena_codegen_dedent(ctx);
        arena_codegen_emit_line(ctx, "}");
        arena_codegen_emit_line(ctx, "");
    }
    
    return ARENA_CODEGEN_OK;
}

// Generate typed template with zones
int arena_codegen_generate_typed_template(arena_codegen_ctx_t* ctx) {
    if (!ctx) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    const char* arena_name = ctx->config.arena_name ? ctx->config.arena_name : "global_arena";
    
    arena_codegen_emit_line(ctx, "// Typed arena zones");
    for (size_t i = 0; i < ctx->zone_count; i++) {
        const arena_zone_config_t* zone = &ctx->zones[i];
        size_t zone_size = arena_codegen_calculate_zone_size(zone);
        
        arena_codegen_emit_line(ctx, "// Zone: %s (%s[%zu])", zone->zone_name, zone->type_name, zone->count);
        arena_codegen_emit_line(ctx, "#define %s_%s_OFFSET %zu", arena_name, zone->zone_name, 
                               i == 0 ? 0 : arena_codegen_calculate_total_size(ctx->zones, i));
        arena_codegen_emit_line(ctx, "#define %s_%s_SIZE %zu", arena_name, zone->zone_name, zone_size);
        arena_codegen_emit_line(ctx, "#define %s_%s_COUNT %zu", arena_name, zone->zone_name, zone->count);
        arena_codegen_emit_line(ctx, "");
        
        // Generate accessor for this zone
        arena_codegen_emit_line(ctx, "static inline %s* %s_get_%s(size_t index) {", 
                               zone->type_name, arena_name, zone->zone_name);
        arena_codegen_indent(ctx);
        arena_codegen_emit_line(ctx, "if (index >= %s_%s_COUNT) return NULL;", arena_name, zone->zone_name);
        arena_codegen_emit_line(ctx, "return (%s*)(%s_storage + %s_%s_OFFSET + index * sizeof(%s));", 
                               zone->type_name, arena_name, arena_name, zone->zone_name, zone->type_name);
        arena_codegen_dedent(ctx);
        arena_codegen_emit_line(ctx, "}");
        arena_codegen_emit_line(ctx, "");
    }
    
    return ARENA_CODEGEN_OK;
}

// Generate complete arena code
int arena_codegen_generate_complete(arena_codegen_ctx_t* ctx) {
    if (!ctx) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    int result;
    
    if ((result = arena_codegen_generate_header(ctx)) != ARENA_CODEGEN_OK) {
        return result;
    }
    
    if ((result = arena_codegen_generate_declarations(ctx)) != ARENA_CODEGEN_OK) {
        return result;
    }
    
    if ((result = arena_codegen_generate_initialization(ctx)) != ARENA_CODEGEN_OK) {
        return result;
    }
    
    // Generate template-specific code
    switch (ctx->template_type) {
        case ARENA_TEMPLATE_TYPED:
            if ((result = arena_codegen_generate_typed_template(ctx)) != ARENA_CODEGEN_OK) {
                return result;
            }
            break;
        case ARENA_TEMPLATE_SIMPLE:
        default:
            // Simple template doesn't need additional code
            break;
    }
    
    if ((result = arena_codegen_generate_accessors(ctx)) != ARENA_CODEGEN_OK) {
        return result;
    }
    
    if (ctx->config.include_guards) {
        arena_codegen_emit_line(ctx, "#endif // %s_ARENA_H", 
                               ctx->config.arena_name ? ctx->config.arena_name : "GENERATED");
    }
    
    return ARENA_CODEGEN_OK;
}

// Size calculation helpers
size_t arena_codegen_calculate_zone_size(const arena_zone_config_t* zone) {
    if (!zone) return 0;
    
    size_t aligned_size = arena_codegen_align_size(zone->type_size, zone->alignment);
    return aligned_size * zone->count;
}

size_t arena_codegen_calculate_total_size(const arena_zone_config_t* zones, size_t count) {
    size_t total = 0;
    for (size_t i = 0; i < count; i++) {
        total += arena_codegen_calculate_zone_size(&zones[i]);
    }
    return total;
}

size_t arena_codegen_align_size(size_t size, size_t alignment) {
    return (size + alignment - 1) & ~(alignment - 1);
}

// Default configurations
arena_codegen_config_t arena_codegen_default_config(void) {
    arena_codegen_config_t config = {
        .total_size = 16 * 1024 * 1024,  // 16MB default
        .alignment = 16,
        .arena_name = "global_arena",
        .type_name = "arena_t",
        .use_static_storage = 1,
        .include_guards = 1,
        .include_debug_info = 0
    };
    return config;
}

arena_zone_config_t arena_codegen_default_zone(const char* name, const char* type, size_t size, size_t count) {
    arena_zone_config_t zone = {
        .zone_name = name,
        .type_name = type,
        .type_size = size,
        .count = count,
        .alignment = 8
    };
    return zone;
}

// Validation functions
int arena_codegen_validate_config(const arena_codegen_config_t* config) {
    if (!config) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    if (config->total_size == 0) return ARENA_CODEGEN_ERROR_INVALID_CONFIG;
    if (config->alignment == 0 || (config->alignment & (config->alignment - 1)) != 0) {
        return ARENA_CODEGEN_ERROR_INVALID_CONFIG;
    }
    
    return ARENA_CODEGEN_OK;
}

int arena_codegen_validate_zone(const arena_zone_config_t* zone) {
    if (!zone) return ARENA_CODEGEN_ERROR_NULL_POINTER;
    
    if (!zone->zone_name || !zone->type_name) return ARENA_CODEGEN_ERROR_INVALID_ZONE;
    if (zone->type_size == 0 || zone->count == 0) return ARENA_CODEGEN_ERROR_INVALID_ZONE;
    if (zone->alignment == 0 || (zone->alignment & (zone->alignment - 1)) != 0) {
        return ARENA_CODEGEN_ERROR_INVALID_ZONE;
    }
    
    return ARENA_CODEGEN_OK;
}

// Error handling
const char* arena_codegen_error_string(arena_codegen_error_t error) {
    switch (error) {
        case ARENA_CODEGEN_OK:
            return "Success";
        case ARENA_CODEGEN_ERROR_NULL_POINTER:
            return "Null pointer error";
        case ARENA_CODEGEN_ERROR_INVALID_CONFIG:
            return "Invalid configuration";
        case ARENA_CODEGEN_ERROR_INVALID_ZONE:
            return "Invalid zone configuration";
        case ARENA_CODEGEN_ERROR_OUTPUT_FAILED:
            return "Output operation failed";
        case ARENA_CODEGEN_ERROR_BUFFER_OVERFLOW:
            return "Buffer overflow";
        case ARENA_CODEGEN_ERROR_UNSUPPORTED_TEMPLATE:
            return "Unsupported template type";
        default:
            return "Unknown error";
    }
}