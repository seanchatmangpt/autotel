# Makefile for BitActor Real Implementation (No Mocks)
# 80/20 Optimized Version

CC = gcc
CFLAGS = -std=c11 -O3 -Wall -Wextra -march=native -I./include -DCNS_DEBUG=0
LDFLAGS = -lm

# Enable all optimizations for real performance
CFLAGS += -funroll-loops -ffast-math -finline-functions
CFLAGS += -fomit-frame-pointer -fstrict-aliasing

# Source files for real implementation
REAL_SOURCES = src/bitactor_80_20_optimized.c

# Object files
REAL_OBJECTS = $(REAL_SOURCES:.c=.o)

# Target executables
REAL_BENCHMARK = bitactor_real_benchmark

# Build rules
all: $(REAL_BENCHMARK)

$(REAL_BENCHMARK): $(REAL_OBJECTS)
	$(CC) $(REAL_OBJECTS) -o $@ $(LDFLAGS)

# Individual object file rules
src/bitactor_80_20_optimized.o: src/bitactor_80_20_optimized.c include/cns/bitactor_80_20.h
	$(CC) $(CFLAGS) -c $< -o $@

# Run the real benchmark
run: $(REAL_BENCHMARK)
	./$(REAL_BENCHMARK)

# Performance comparison between mock and real implementations
compare: $(REAL_BENCHMARK)
	@echo "🔍 Performance Comparison: Mock vs Real Implementations"
	@echo "======================================================"
	@echo ""
	@echo "Running REAL implementation benchmark:"
	@./$(REAL_BENCHMARK)
	@echo ""
	@echo "Key improvements over mock implementations:"
	@echo "  ✅ Real CPU cycle counting instead of mock counters"
	@echo "  ✅ O(1) hash-based registry instead of O(n) linear search"  
	@echo "  ✅ Actual entanglement propagation instead of print statements"
	@echo "  ✅ Entropy-based randomization instead of simple counters"
	@echo "  ✅ Sophisticated pattern matching instead of basic hash comparison"

# Intensive performance test
stress: $(REAL_BENCHMARK)
	@echo "🔥 Running stress test with real implementations..."
	@for i in 1 2 3 4 5; do \
		echo "Stress test run $$i:"; \
		./$(REAL_BENCHMARK) | grep -E "(Average|Sub-100ns|Trinity compliance)"; \
		echo ""; \
	done

# Profile the real implementation
profile: CFLAGS += -pg -g
profile: $(REAL_BENCHMARK)
	./$(REAL_BENCHMARK)
	gprof $(REAL_BENCHMARK) gmon.out > profile_analysis.txt
	@echo "Profile analysis saved to profile_analysis.txt"

# Memory analysis
memcheck: $(REAL_BENCHMARK)
	valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./$(REAL_BENCHMARK)

# Assembly output for performance analysis
assembly: src/bitactor_80_20_optimized.c
	$(CC) $(CFLAGS) -S -fverbose-asm $< -o bitactor_real_assembly.s
	@echo "Assembly output saved to bitactor_real_assembly.s"

# Trinity compliance validation
trinity: $(REAL_BENCHMARK)
	@echo "🛡️ Trinity Compliance Validation (8T/8H/8M)"
	@echo "============================================"
	@./$(REAL_BENCHMARK) | grep -E "(Trinity compliance|8T|cycles)" || true
	@echo ""
	@echo "Checking binary size compliance:"
	@size $(REAL_BENCHMARK)
	@echo ""
	@echo "Checking alignment compliance:"
	@objdump -h $(REAL_BENCHMARK) | grep -E "(\.text|\.data)" || true

# Clean build artifacts
clean:
	rm -f $(REAL_OBJECTS) $(REAL_BENCHMARK) gmon.out profile_analysis.txt bitactor_real_assembly.s

# Help target
help:
	@echo "BitActor Real Implementation (No Mocks) - Make targets:"
	@echo "  all      - Build the real implementation benchmark"
	@echo "  run      - Build and run the benchmark"  
	@echo "  compare  - Compare mock vs real performance"
	@echo "  stress   - Run intensive stress tests"
	@echo "  profile  - Profile the implementation"
	@echo "  memcheck - Run memory analysis"
	@echo "  assembly - Generate assembly output"
	@echo "  trinity  - Validate Trinity compliance"
	@echo "  clean    - Clean build artifacts"
	@echo "  help     - Show this help"

.PHONY: all run compare stress profile memcheck assembly trinity clean help