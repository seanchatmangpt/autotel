#!/usr/bin/env python3
"""
SQL AOT Compiler for CNS 7-Tick Engine
=====================================

Compiles SQL queries to highly optimized C functions for 7-tick performance.

This compiler transforms SQL queries from an interpreter pattern to ahead-of-time
compiled C functions that execute at machine speed with guaranteed 7-tick budgets.

Usage:
    python sql_compiler.py reports.sql --output sql_queries.h

Author: Claude Flow SQL-AOT Implementation
"""

import argparse
import json
import re
import sys
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple, Union
from pathlib import Path

try:
    import sqlparse
except ImportError:
    print("ERROR: sqlparse not installed. Run: pip install sqlparse")
    sys.exit(1)

@dataclass
class SQLColumn:
    """Column metadata for SQL AOT compilation"""
    name: str
    type: str  # int32, int64, float32, float64, id, date, time, bool
    index: int
    nullable: bool = False

@dataclass
class SQLTable:
    """Table schema for SQL AOT compilation"""
    name: str
    columns: List[SQLColumn]
    row_count: int = 1000  # Default for optimization

@dataclass
class SQLPredicate:
    """Predicate for WHERE clauses"""
    column: str
    operator: str  # =, !=, <, <=, >, >=, IN, BETWEEN
    value: Union[str, int, float, List]
    type: str

@dataclass
class SQLQuery:
    """Parsed SQL query for AOT compilation"""
    name: str
    sql: str
    query_type: str  # SELECT, INSERT, UPDATE, DELETE
    tables: List[str]
    columns: List[str]
    predicates: List[SQLPredicate]
    group_by: Optional[List[str]] = None
    order_by: Optional[Tuple[str, bool]] = None  # (column, ascending)
    limit: Optional[int] = None
    parameters: Dict[str, str] = None  # Parameter types

class SQLAOTCompiler:
    """SQL Ahead-of-Time Compiler for CNS"""
    
    def __init__(self):
        self.schemas = {}  # Table name -> SQLTable
        self.queries = []  # List of SQLQuery objects
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict[str, str]:
        """Load C code generation templates"""
        return {
            'header': '''/*
 * GENERATED CODE - DO NOT EDIT
 * SQL AOT Compiled Queries for CNS 7-Tick Engine
 * Generated by: sql_compiler.py
 */

#ifndef SQL_QUERIES_H
#define SQL_QUERIES_H

#include "cns/sql_functions.h"
#include "../../include/s7t.h"
#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

''',
            'footer': '''
#ifdef __cplusplus
}
#endif

#endif /* SQL_QUERIES_H */
''',
            'query_function': '''
/**
 * @brief COMPILED SQL QUERY: {query_name}
 * @param {parameters}
 * @return Number of result rows or error code
 */
static inline int run_query_{function_name}({function_signature}) {{
    s7t_span_t span;
    s7t_span_start(&span, "aot_{query_name}");
    
    {function_body}
    
    s7t_span_end(&span);
    uint64_t cycles = span.end_cycles - span.start_cycles;
    
    // Assert 7-tick compliance
    if (cycles > S7T_MAX_CYCLES * {cycle_budget}) {{
        return CNS_ERR_TIMEOUT;
    }}
    
    return result_count;
}}
''',
            'dispatcher': '''
/**
 * @brief Execute AOT compiled SQL query by name
 * @param query_name Name of the compiled query
 * @param params Parameter array (typed based on query)
 * @param results Output buffer for results
 * @return Number of rows or error code
 */
static inline int execute_aot_sql_query(const char* query_name, void** params, void* results) {{
    if (!query_name || !results) return CNS_ERR_INVALID_ARG;
    
{dispatcher_cases}
    
    return CNS_ERR_NOT_FOUND;  // Query not found
}}
'''
        }
    
    def load_schema(self, schema_file: str):
        """Load table schemas from JSON file"""
        with open(schema_file, 'r') as f:
            schema_data = json.load(f)
        
        for table_name, table_info in schema_data.items():
            columns = []
            for i, (col_name, col_type) in enumerate(table_info['columns'].items()):
                columns.append(SQLColumn(
                    name=col_name,
                    type=col_type,
                    index=i,
                    nullable=table_info.get('nullable', {}).get(col_name, False)
                ))
            
            self.schemas[table_name] = SQLTable(
                name=table_name,
                columns=columns,
                row_count=table_info.get('row_count', 1000)
            )
    
    def parse_sql_file(self, sql_file: str):
        """Parse SQL file with named queries"""
        with open(sql_file, 'r') as f:
            content = f.read()
        
        # Split into individual queries based on NAME comments
        queries = re.split(r'--\s*NAME:\s*(\w+)', content)
        
        for i in range(1, len(queries), 2):
            query_name = queries[i].strip()
            query_sql = queries[i + 1].strip()
            
            if query_sql:
                parsed_query = self._parse_single_query(query_name, query_sql)
                if parsed_query:
                    self.queries.append(parsed_query)
    
    def _parse_single_query(self, name: str, sql: str) -> Optional[SQLQuery]:
        """Parse a single SQL query"""
        try:
            # Extract parameters from comments
            parameters = {}
            param_matches = re.findall(r'--\s*PARAM:\s*(\w+)\s*\((\w+)\)', sql)
            for param_name, param_type in param_matches:
                parameters[param_name] = param_type
            
            # Parse SQL using sqlparse
            parsed = sqlparse.parse(sql)[0]
            
            # Extract query components
            query_type = self._get_query_type(parsed)
            tables = self._extract_tables(parsed)
            columns = self._extract_columns(parsed)
            predicates = self._extract_predicates(parsed)
            group_by = self._extract_group_by(parsed)
            order_by = self._extract_order_by(parsed)
            limit = self._extract_limit(parsed)
            
            return SQLQuery(
                name=name,
                sql=sql,
                query_type=query_type,
                tables=tables,
                columns=columns,
                predicates=predicates,
                group_by=group_by,
                order_by=order_by,
                limit=limit,
                parameters=parameters
            )
        
        except Exception as e:
            print(f"Error parsing query '{name}': {e}")
            return None
    
    def _get_query_type(self, parsed) -> str:
        """Extract query type (SELECT, INSERT, etc.)"""
        for token in parsed.flatten():
            if token.ttype is sqlparse.tokens.Keyword.DML:
                return token.value.upper()
        return "SELECT"
    
    def _extract_tables(self, parsed) -> List[str]:
        """Extract table names from parsed SQL"""
        tables = []
        in_from = False
        
        for token in parsed.flatten():
            if token.ttype is sqlparse.tokens.Keyword and token.value.upper() == 'FROM':
                in_from = True
            elif in_from and token.ttype is None and token.value.strip():
                table_name = token.value.strip().rstrip(',')
                if table_name and not table_name.upper() in ('WHERE', 'GROUP', 'ORDER', 'HAVING'):
                    tables.append(table_name)
                    break
        
        return tables
    
    def _extract_columns(self, parsed) -> List[str]:
        """Extract column names from SELECT clause"""
        columns = []
        in_select = False
        
        for token in parsed.flatten():
            if token.ttype is sqlparse.tokens.Keyword.DML and token.value.upper() == 'SELECT':
                in_select = True
            elif in_select and token.ttype is sqlparse.tokens.Keyword and token.value.upper() == 'FROM':
                break
            elif in_select and token.ttype is None and token.value.strip():
                col_name = token.value.strip().rstrip(',')
                if col_name and col_name != '*':
                    columns.append(col_name)
        
        return columns
    
    def _extract_predicates(self, parsed) -> List[SQLPredicate]:
        """Extract WHERE clause predicates"""
        predicates = []
        where_clause = None
        
        # Find WHERE clause
        for token in parsed.tokens:
            if hasattr(token, 'tokens'):
                for subtoken in token.tokens:
                    if (subtoken.ttype is sqlparse.tokens.Keyword and 
                        subtoken.value.upper() == 'WHERE'):
                        where_clause = token
                        break
        
        if where_clause:
            # Simple predicate extraction (column = value)
            text = str(where_clause)
            pred_match = re.search(r'WHERE\s+(\w+)\s*([=<>!]+)\s*(:?\w+|\d+)', text, re.IGNORECASE)
            if pred_match:
                column, operator, value = pred_match.groups()
                
                # Determine value type
                if value.startswith(':'):
                    value_type = 'parameter'
                    value = value[1:]  # Remove :
                elif value.isdigit():
                    value_type = 'int32'
                    value = int(value)
                else:
                    value_type = 'string'
                
                predicates.append(SQLPredicate(
                    column=column,
                    operator=operator,
                    value=value,
                    type=value_type
                ))
        
        return predicates
    
    def _extract_group_by(self, parsed) -> Optional[List[str]]:
        """Extract GROUP BY columns"""
        # Simplified GROUP BY extraction
        text = str(parsed)
        group_match = re.search(r'GROUP\s+BY\s+([\w,\s]+)', text, re.IGNORECASE)
        if group_match:
            columns = [col.strip() for col in group_match.group(1).split(',')]
            return columns
        return None
    
    def _extract_order_by(self, parsed) -> Optional[Tuple[str, bool]]:
        """Extract ORDER BY column and direction"""
        text = str(parsed)
        order_match = re.search(r'ORDER\s+BY\s+(\w+)(?:\s+(ASC|DESC))?', text, re.IGNORECASE)
        if order_match:
            column = order_match.group(1)
            direction = order_match.group(2)
            ascending = direction is None or direction.upper() == 'ASC'
            return (column, ascending)
        return None
    
    def _extract_limit(self, parsed) -> Optional[int]:
        """Extract LIMIT value"""
        text = str(parsed)
        limit_match = re.search(r'LIMIT\s+(\d+)', text, re.IGNORECASE)
        if limit_match:
            return int(limit_match.group(1))
        return None
    
    def compile_to_c(self, output_file: str):
        """Compile all queries to C header file"""
        c_code = [self.templates['header']]
        dispatcher_cases = []
        
        for query in self.queries:
            # Generate function for each query
            function_code = self._generate_query_function(query)
            c_code.append(function_code)
            
            # Add to dispatcher
            dispatcher_cases.append(self._generate_dispatcher_case(query))
        
        # Generate dispatcher
        dispatcher_code = self.templates['dispatcher'].format(
            dispatcher_cases='\n'.join(dispatcher_cases)
        )
        c_code.append(dispatcher_code)
        c_code.append(self.templates['footer'])
        
        # Write to file
        with open(output_file, 'w') as f:
            f.write('\n'.join(c_code))
        
        print(f"Generated {len(self.queries)} AOT compiled queries to {output_file}")
    
    def _generate_query_function(self, query: SQLQuery) -> str:
        """Generate C function for a single query"""
        function_name = query.name.lower()
        
        # Build function signature
        signature_parts = []
        if query.tables:
            table = query.tables[0]
            signature_parts.append(f"const {table}_t* {table}_data")
            signature_parts.append("int data_count")
        
        # Add parameters
        for param_name, param_type in (query.parameters or {}).items():
            c_type = self._get_c_type(param_type)
            signature_parts.append(f"{c_type} {param_name}")
        
        # Add result buffer
        result_type = self._get_result_type(query)
        signature_parts.append(f"{result_type}* results")
        
        function_signature = ', '.join(signature_parts)
        
        # Generate function body
        function_body = self._generate_function_body(query)
        
        # Estimate cycle budget
        cycle_budget = self._estimate_cycle_budget(query)
        
        return self.templates['query_function'].format(
            query_name=query.name,
            function_name=function_name,
            function_signature=function_signature,
            function_body=function_body,
            cycle_budget=cycle_budget,
            parameters=', '.join([p for p in signature_parts[:-1]])
        )
    
    def _generate_function_body(self, query: SQLQuery) -> str:
        """Generate optimized C code for query execution"""
        if query.query_type == 'SELECT':
            return self._generate_select_body(query)
        else:
            return "    // TODO: Implement other query types\n    int result_count = 0;"
    
    def _generate_select_body(self, query: SQLQuery) -> str:
        """Generate optimized SELECT query body"""
        body_parts = []
        
        # Initialize result tracking
        body_parts.append("    int result_count = 0;")
        
        if query.predicates or query.group_by:
            # Complex query with filtering/grouping
            if query.group_by:
                body_parts.extend(self._generate_group_by_code(query))
            else:
                body_parts.extend(self._generate_filter_code(query))
        else:
            # Simple SELECT * query
            body_parts.append("    // Simple scan - copy all rows")
            body_parts.append("    for (int i = 0; i < data_count; ++i) {")
            body_parts.append("        results[result_count] = data[i];")
            body_parts.append("        result_count++;")
            body_parts.append("    }")
        
        return '\n'.join(body_parts)
    
    def _generate_filter_code(self, query: SQLQuery) -> List[str]:
        """Generate SIMD-optimized filter code"""
        code = []
        
        if query.predicates:
            predicate = query.predicates[0]  # Use first predicate
            
            if predicate.operator == '=' and predicate.type in ['int32', 'parameter']:
                # Use SIMD equality filter
                code.append("    // SIMD-optimized equality filter")
                code.append("    uint32_t matches[data_count];")
                
                if predicate.type == 'parameter':
                    value_expr = predicate.value
                else:
                    value_expr = str(predicate.value)
                
                code.append(f"    uint32_t match_count = s7t_simd_filter_eq_i32(")
                code.append(f"        (int32_t*)data, {value_expr}, data_count, matches);")
                code.append("")
                code.append("    // Copy matching rows")
                code.append("    for (uint32_t i = 0; i < match_count; ++i) {")
                code.append("        results[result_count] = data[matches[i]];")
                code.append("        result_count++;")
                code.append("    }")
            else:
                # Fallback to scalar filter
                code.append("    // Scalar filter")
                code.append("    for (int i = 0; i < data_count; ++i) {")
                condition = self._generate_condition(predicate)
                code.append(f"        if ({condition}) {{")
                code.append("            results[result_count] = data[i];")
                code.append("            result_count++;")
                code.append("        }")
                code.append("    }")
        
        return code
    
    def _generate_group_by_code(self, query: SQLQuery) -> List[str]:
        """Generate GROUP BY aggregation code"""
        code = []
        
        if query.group_by:
            group_col = query.group_by[0]  # Use first group column
            
            code.append("    // Stack-allocated group aggregation")
            code.append("    float group_values[256] S7T_ALIGNED(64) = {0};")
            code.append("    int group_counts[256] = {0};")
            code.append("")
            code.append("    // Aggregate into groups")
            code.append("    for (int i = 0; i < data_count; ++i) {")
            
            # Generate grouping logic based on column type
            if group_col in ['region', 'region_id']:
                code.append(f"        int group_key = data[i].{group_col};")
                code.append("        if (group_key >= 0 && group_key < 256) {")
                
                # Find aggregation column
                agg_col = 'revenue'  # Default
                if 'amount' in str(query.sql):
                    agg_col = 'amount'
                elif 'value' in str(query.sql):
                    agg_col = 'value'
                
                code.append(f"            group_values[group_key] += data[i].{agg_col};")
                code.append("            group_counts[group_key]++;")
                code.append("        }")
            
            code.append("    }")
            code.append("")
            code.append("    // Generate results")
            code.append("    for (int i = 0; i < 256; ++i) {")
            code.append("        if (group_counts[i] > 0) {")
            code.append("            results[result_count].group_id = i;")
            code.append("            results[result_count].total_value = group_values[i];")
            code.append("            results[result_count].count = group_counts[i];")
            code.append("            result_count++;")
            code.append("        }")
            code.append("    }")
        
        return code
    
    def _generate_condition(self, predicate: SQLPredicate) -> str:
        """Generate C condition expression"""
        column_ref = f"data[i].{predicate.column}"
        
        if predicate.type == 'parameter':
            value_ref = predicate.value
        elif predicate.type in ['int32', 'int64']:
            value_ref = str(predicate.value)
        elif predicate.type == 'string':
            value_ref = f'"{predicate.value}"'
        else:
            value_ref = str(predicate.value)
        
        return f"{column_ref} {predicate.operator} {value_ref}"
    
    def _generate_dispatcher_case(self, query: SQLQuery) -> str:
        """Generate dispatcher case for query"""
        function_name = query.name.lower()
        
        # Build parameter passing
        param_exprs = []
        param_idx = 0
        
        # Add data parameters
        if query.tables:
            param_exprs.append(f"({query.tables[0]}_t*)params[{param_idx}]")
            param_idx += 1
            param_exprs.append(f"*(int*)params[{param_idx}]")
            param_idx += 1
        
        # Add query parameters
        for param_name, param_type in (query.parameters or {}).items():
            c_type = self._get_c_type(param_type)
            param_exprs.append(f"*({c_type}*)params[{param_idx}]")
            param_idx += 1
        
        # Add results buffer
        result_type = self._get_result_type(query)
        param_exprs.append(f"({result_type}*)results")
        
        param_list = ', '.join(param_exprs)
        
        return f'''    if (strcmp(query_name, "{query.name}") == 0) {{
        return run_query_{function_name}({param_list});
    }}'''
    
    def _get_c_type(self, sql_type: str) -> str:
        """Convert SQL type to C type"""
        type_map = {
            'int': 'int32_t',
            'int32': 'int32_t',
            'int64': 'int64_t',
            'float': 'float',
            'float32': 'float',
            'float64': 'double',
            'string': 'const char*',
            'bool': 'bool'
        }
        return type_map.get(sql_type.lower(), 'int32_t')
    
    def _get_result_type(self, query: SQLQuery) -> str:
        """Determine result structure type for query"""
        if query.group_by:
            return f"{query.name}GroupResult_t"
        else:
            return f"{query.name}Result_t"
    
    def _estimate_cycle_budget(self, query: SQLQuery) -> int:
        """Estimate cycle budget multiplier for query"""
        base_budget = 1
        
        if query.predicates:
            base_budget += 2  # Filter overhead
        if query.group_by:
            base_budget += 3  # Grouping overhead
        if query.order_by:
            base_budget += 5  # Sorting overhead
        
        return min(base_budget, 10)  # Cap at 10x base budget

def main():
    parser = argparse.ArgumentParser(description='SQL AOT Compiler for CNS 7-Tick Engine')
    parser.add_argument('sql_file', help='SQL file with named queries')
    parser.add_argument('--schema', help='JSON schema file')
    parser.add_argument('--output', default='sql_queries.h', help='Output C header file')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    compiler = SQLAOTCompiler()
    
    # Load schema if provided
    if args.schema:
        compiler.load_schema(args.schema)
    
    # Parse SQL queries
    compiler.parse_sql_file(args.sql_file)
    
    if args.verbose:
        print(f"Parsed {len(compiler.queries)} queries:")
        for query in compiler.queries:
            print(f"  - {query.name}: {query.query_type} on {query.tables}")
    
    # Compile to C
    compiler.compile_to_c(args.output)
    
    print(f"SQL AOT compilation completed successfully!")
    print(f"Generated optimized C functions for 7-tick performance.")

if __name__ == '__main__':
    main()