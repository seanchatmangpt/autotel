/*
 * Ontology Inference Rules - Generated by CNS OWL AOT Compiler
 * DO NOT EDIT - This file is automatically generated
 * 
 * These functions implement OWL semantics as optimized C code:
 * - Static inline functions for maximum performance (7-tick compliant)
 * - Pre-computed inferences using || short-circuit evaluation
 * - Direct integration with CNS SPARQL engine
 */

#ifndef ONTOLOGY_RULES_H
#define ONTOLOGY_RULES_H

#include "ontology_ids.h"
#include "cns/engines/sparql.h"
#include <stdbool.h>

/* Global SPARQL engine - assumed to be available */
extern CNSSparqlEngine* g_sparql_engine;

/* ===== SUBCLASS CHECKING FUNCTIONS ===== */

/**
 * @brief Checks if an entity is of type Employee (including subclasses: Manager, IndividualContributor)
 * @param entity_id The entity ID to check
 * @return true if entity is Employee or any of its subclasses
 */
static inline bool is_Employee(cns_entity_id_t entity_id) {
    return cns_sparql_ask_pattern(g_sparql_engine, entity_id, CNS_TYPE_PROPERTY, CNS_EMPLOYEE_CLASS) ||\n           cns_sparql_ask_pattern(g_sparql_engine, entity_id, CNS_TYPE_PROPERTY, CNS_MANAGER_CLASS) ||\n           cns_sparql_ask_pattern(g_sparql_engine, entity_id, CNS_TYPE_PROPERTY, CNS_INDIVIDUALCONTRIBUTOR_CLASS);
}

/* ===== TRANSITIVE PROPERTY FUNCTIONS ===== */

/**
 * @brief Checks transitive ancestor relationship (pre-computed at build time)
 * @param subject_id Subject entity ID
 * @param object_id Object entity ID  
 * @return true if subject ancestor object (direct or transitive)
 */
static inline bool check_ancestor_transitive(cns_entity_id_t subject_id, cns_entity_id_t object_id) {
    /* Transitive closure pre-computed - just a single lookup */
    return cns_sparql_ask_pattern(g_sparql_engine, subject_id, CNS_ANCESTOR_PROPERTY, object_id);
}

/* ===== SYMMETRIC PROPERTY FUNCTIONS ===== */

/**
 * @brief Checks symmetric worksWith relationship
 * @param entity1_id First entity ID
 * @param entity2_id Second entity ID
 * @return true if entity1 worksWith entity2 OR entity2 worksWith entity1
 */
static inline bool check_worksWith_symmetric(cns_entity_id_t entity1_id, cns_entity_id_t entity2_id) {
    /* Check both directions for symmetry */
    return cns_sparql_ask_pattern(g_sparql_engine, entity1_id, CNS_WORKSWITH_PROPERTY, entity2_id) ||
           cns_sparql_ask_pattern(g_sparql_engine, entity2_id, CNS_WORKSWITH_PROPERTY, entity1_id);
}

/* ===== INVERSE PROPERTY FUNCTIONS ===== */

/**
 * @brief Checks inverse relationship between isManagedBy and manages
 * @param subject_id Subject entity ID
 * @param object_id Object entity ID
 * @return true if subject isManagedBy object OR object manages subject
 */
static inline bool check_isManagedBy_manages_inverse(cns_entity_id_t subject_id, cns_entity_id_t object_id) {
    /* Check both inverse directions */
    return cns_sparql_ask_pattern(g_sparql_engine, subject_id, CNS_ISMANAGEDBY_PROPERTY, object_id) ||
           cns_sparql_ask_pattern(g_sparql_engine, object_id, CNS_MANAGES_PROPERTY, subject_id);
}

#endif /* ONTOLOGY_RULES_H */
