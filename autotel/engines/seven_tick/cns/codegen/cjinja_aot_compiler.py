#!/usr/bin/env python3
"""
CJinja Ahead-of-Time (AOT) Compiler
Compiles Jinja2 templates into optimized C functions for 7-tick performance.

This implements the complete AOT pipeline from JINJA-AOT.md:
1. Parse Jinja2 templates into AST using official Jinja2 library
2. Generate type-safe C context structs
3. Emit native C functions with inlined template logic
4. Create dispatcher for runtime template selection
"""

import sys
import os
import argparse
import json
import re
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field

try:
    from jinja2 import Environment, FileSystemLoader, Template, meta
    from jinja2.nodes import *
    HAS_JINJA2 = True
except ImportError:
    HAS_JINJA2 = False
    print("Warning: jinja2 library not found. Install with: pip install jinja2")

@dataclass
class TemplateVariable:
    """Represents a variable used in a template"""
    name: str
    type: str = "string"  # string, int, float, bool, array
    array_type: Optional[str] = None  # For arrays, the type of elements
    is_required: bool = True
    default_value: Optional[str] = None

@dataclass
class TemplateContext:
    """Context structure for a compiled template"""
    name: str
    variables: List[TemplateVariable] = field(default_factory=list)
    structs: List['TemplateContext'] = field(default_factory=list)  # Nested structs

@dataclass
class CompiledTemplate:
    """Represents a compiled template"""
    name: str
    source_file: str
    context: TemplateContext
    c_function_name: str
    c_code: str
    has_loops: bool = False
    has_conditionals: bool = False
    complexity_score: int = 0

class CJinjaASTAnalyzer:
    """Analyzes Jinja2 AST to extract variables and generate context structs"""
    
    def __init__(self):
        self.variables = {}
        self.complexity_score = 0
        self.has_loops = False
        self.has_conditionals = False
    
    def analyze_template(self, template_string: str, template_name: str) -> Tuple[TemplateContext, int, bool, bool]:
        """Analyze a template and return context structure and metadata"""
        if not HAS_JINJA2:
            raise RuntimeError("jinja2 library required for template analysis")
        
        # Parse template into AST
        env = Environment()
        ast = env.parse(template_string)
        
        # Extract undeclared variables (template variables)
        undeclared = meta.find_undeclared_variables(ast)
        
        # Analyze AST nodes for complexity and variable types
        self._analyze_node(ast)
        
        # Create context structure
        variables = []
        for var_name in undeclared:
            var_type = self._infer_variable_type(var_name, ast)
            variables.append(TemplateVariable(
                name=var_name,
                type=var_type,
                is_required=True
            ))
        
        context = TemplateContext(
            name=f"{template_name}_Context",
            variables=variables
        )
        
        return context, self.complexity_score, self.has_loops, self.has_conditionals
    
    def _analyze_node(self, node):
        """Recursively analyze AST nodes"""
        if isinstance(node, For):
            self.has_loops = True
            self.complexity_score += 10
        elif isinstance(node, If):
            self.has_conditionals = True
            self.complexity_score += 5
        elif isinstance(node, Filter):
            self.complexity_score += 2
        elif isinstance(node, Getattr):
            # Object property access (e.g., product.name)
            self.complexity_score += 1
        
        # Recursively analyze child nodes
        for child in node.iter_child_nodes():
            self._analyze_node(child)
    
    def _infer_variable_type(self, var_name: str, ast) -> str:
        """Infer variable type from usage patterns in AST"""
        # Default to string, but could be enhanced with more sophisticated analysis
        # Look for mathematical operations, comparisons, etc.
        return "string"

class CJinjaCodeGenerator:
    """Generates optimized C code from template AST"""
    
    def __init__(self):
        self.indent_level = 0
    
    def generate_template_function(self, template: CompiledTemplate) -> str:
        """Generate C function for a compiled template"""
        template_string = self._load_template_content(template.source_file)
        
        if not HAS_JINJA2:
            # Fallback: generate simple variable substitution
            return self._generate_simple_substitution(template, template_string)
        
        # Parse with Jinja2 for full feature support
        env = Environment()
        ast = env.parse(template_string)
        
        # Generate C function
        c_code = f"""/**
 * @brief COMPILED JINJA TEMPLATE: {template.name}
 * Generated by CJinja AOT Compiler - DO NOT EDIT
 * Complexity Score: {template.complexity_score}
 * Features: {'loops' if template.has_loops else ''} {'conditionals' if template.has_conditionals else ''}
 */
static inline int render_{template.c_function_name}(
    const {template.context.name}* ctx,
    char* buffer,
    size_t buffer_size
) {{
    char* ptr = buffer;
    char* const end = buffer + buffer_size;
    
    if (!ctx || !buffer || buffer_size == 0) {{
        return -1;
    }}
    
"""
        
        # Generate code from AST
        c_code += self._generate_from_ast(ast)
        
        c_code += """    
    return ptr - buffer;
}
"""
        
        return c_code
    
    def _generate_from_ast(self, node) -> str:
        """Generate C code from AST node"""
        if isinstance(node, Template):
            # Root template node
            code = ""
            for child in node.body:
                code += self._generate_from_ast(child)
            return code
        
        elif isinstance(node, Output):
            # Output node contains template text and expressions
            code = ""
            for child in node.nodes:
                if isinstance(child, TemplateData):
                    # Static text
                    escaped_text = child.data.replace('"', '\\"').replace('\n', '\\n')
                    code += f'    ptr += snprintf(ptr, end - ptr, "{escaped_text}");\n'
                elif isinstance(child, Name):
                    # Variable reference
                    code += f'    ptr += snprintf(ptr, end - ptr, "%s", ctx->{child.name});\n'
                elif isinstance(child, Getattr):
                    # Object property access (e.g., product.name)
                    obj_name = child.node.name if hasattr(child.node, 'name') else 'obj'
                    attr_name = child.attr
                    code += f'    ptr += snprintf(ptr, end - ptr, "%s", ctx->{obj_name}.{attr_name});\n'
            return code
        
        elif isinstance(node, For):
            # For loop
            target = node.target.name if hasattr(node.target, 'name') else 'item'
            iter_var = node.iter.name if hasattr(node.iter, 'name') else 'items'
            
            code = f"""    /* {% for {target} in {iter_var} %} */
    for (int i = 0; i < ctx->{iter_var}_count; ++i) {{
        const {target}_t* {target} = &ctx->{iter_var}[i];
        
"""
            # Generate loop body
            for child in node.body:
                body_code = self._generate_from_ast(child)
                # Indent loop body
                code += "    " + body_code.replace('\n', '\n    ')
            
            code += "    }\n"
            return code
        
        elif isinstance(node, If):
            # If conditional
            test_var = node.test.name if hasattr(node.test, 'name') else 'condition'
            
            code = f"""    /* {% if {test_var} %} */
    if (ctx->{test_var}) {{
"""
            # Generate if body
            for child in node.body:
                body_code = self._generate_from_ast(child)
                code += "    " + body_code.replace('\n', '\n    ')
            
            code += "    }\n"
            
            # Handle else clause if present
            if node.orelse:
                code += "    else {\n"
                for child in node.orelse:
                    body_code = self._generate_from_ast(child)
                    code += "    " + body_code.replace('\n', '\n    ')
                code += "    }\n"
            
            return code
        
        else:
            # Recursively handle other nodes
            code = ""
            for child in node.iter_child_nodes():
                code += self._generate_from_ast(child)
            return code
    
    def _generate_simple_substitution(self, template: CompiledTemplate, template_string: str) -> str:
        """Generate simple variable substitution (fallback when Jinja2 not available)"""
        c_code = f"""/**
 * @brief COMPILED JINJA TEMPLATE: {template.name} (Simple Mode)
 * Generated by CJinja AOT Compiler - DO NOT EDIT
 */
static inline int render_{template.c_function_name}(
    const {template.context.name}* ctx,
    char* buffer,
    size_t buffer_size
) {{
    char* ptr = buffer;
    char* const end = buffer + buffer_size;
    const char* template_str = "{template_string.replace('"', '\\"').replace('\n', '\\n')}";
    
    /* Simple variable substitution */
    size_t template_len = strlen(template_str);
    size_t i = 0;
    
    while (i < template_len && ptr < end - 1) {{
        if (i + 3 < template_len && template_str[i] == '{{' && template_str[i+1] == '{{') {{
            /* Find variable name */
            size_t var_start = i + 2;
            size_t var_end = var_start;
            
            while (var_end < template_len && !(template_str[var_end] == '}}' && template_str[var_end+1] == '}}')) {{
                var_end++;
            }}
            
            if (var_end < template_len) {{
                /* Extract and substitute variable */
"""
        
        # Generate variable substitution code for each context variable
        for var in template.context.variables:
            var_len = len(var.name)
            c_code += f"""                if (var_end - var_start == {var_len} && strncmp(template_str + var_start, "{var.name}", {var_len}) == 0) {{
                    ptr += snprintf(ptr, end - ptr, "%s", ctx->{var.name});
                }} else """
        
        c_code += """                {
                    /* Unknown variable, skip */
                }
                
                i = var_end + 2;
                continue;
            }
        }
        
        /* Copy regular character */
        *ptr++ = template_str[i++];
    }
    
    *ptr = '\\0';
    return ptr - buffer;
}
"""
        
        return c_code
    
    def _load_template_content(self, file_path: str) -> str:
        """Load template content from file"""
        try:
            with open(file_path, 'r') as f:
                return f.read()
        except FileNotFoundError:
            return f"/* Template {file_path} not found */"

class CJinjaAOTCompiler:
    """Main AOT compiler for CJinja templates"""
    
    def __init__(self):
        self.analyzer = CJinjaASTAnalyzer()
        self.code_generator = CJinjaCodeGenerator()
        self.compiled_templates = []
    
    def compile_template_directory(self, template_dir: Path) -> List[CompiledTemplate]:
        """Compile all templates in a directory"""
        templates = []
        
        if not template_dir.exists():
            print(f"Warning: Template directory {template_dir} not found")
            return templates
        
        for template_file in template_dir.glob("*.j2"):
            try:
                template = self._compile_template_file(template_file)
                templates.append(template)
                print(f"    âœ“ Compiled {template.name} (complexity: {template.complexity_score})")
            except Exception as e:
                print(f"    âŒ Failed to compile {template_file}: {e}")
        
        return templates
    
    def _compile_template_file(self, template_path: Path) -> CompiledTemplate:
        """Compile a single template file"""
        template_name = template_path.stem
        
        # Load template content
        with open(template_path, 'r') as f:
            template_content = f.read()
        
        # Analyze template
        context, complexity, has_loops, has_conditionals = self.analyzer.analyze_template(
            template_content, template_name
        )
        
        # Create compiled template
        compiled = CompiledTemplate(
            name=template_name,
            source_file=str(template_path),
            context=context,
            c_function_name=template_name.replace('-', '_').replace('.', '_'),
            c_code="",  # Will be generated
            has_loops=has_loops,
            has_conditionals=has_conditionals,
            complexity_score=complexity
        )
        
        # Generate C code
        compiled.c_code = self.code_generator.generate_template_function(compiled)
        
        return compiled
    
    def generate_headers(self, templates: List[CompiledTemplate], output_dir: Path):
        """Generate C header files for compiled templates"""
        
        # Generate main templates header
        self._generate_templates_header(templates, output_dir)
        
        # Generate dispatcher header
        self._generate_dispatcher_header(templates, output_dir)
        
        # Generate context parsing header
        self._generate_context_parser_header(templates, output_dir)
    
    def _generate_templates_header(self, templates: List[CompiledTemplate], output_dir: Path):
        """Generate cjinja_templates.h with compiled template functions"""
        header_content = '''/*
 * CJinja Compiled Templates - Generated by CJinja AOT Compiler
 * DO NOT EDIT - This file is automatically generated
 */

#ifndef CJINJA_TEMPLATES_H
#define CJINJA_TEMPLATES_H

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>

/* Performance measurement */
static inline uint64_t cjinja_get_cycles(void) {
    return __builtin_readcyclecounter();
}

'''
        
        # Generate context structures
        for template in templates:
            header_content += self._generate_context_struct(template.context)
        
        # Generate template functions
        for template in templates:
            header_content += template.c_code + "\n"
        
        header_content += "\n#endif /* CJINJA_TEMPLATES_H */\n"
        
        with open(output_dir / "cjinja_templates.h", "w") as f:
            f.write(header_content)
    
    def _generate_context_struct(self, context: TemplateContext) -> str:
        """Generate C struct for template context"""
        struct_code = f"""
/* Context structure for template: {context.name} */
typedef struct {{
"""
        
        for var in context.variables:
            if var.type == "string":
                struct_code += f"    char {var.name}[256];  /* String variable */\n"
            elif var.type == "int":
                struct_code += f"    int {var.name};       /* Integer variable */\n"
            elif var.type == "float":
                struct_code += f"    double {var.name};    /* Float variable */\n"
            elif var.type == "bool":
                struct_code += f"    bool {var.name};      /* Boolean variable */\n"
            elif var.type == "array":
                struct_code += f"    void* {var.name};     /* Array variable */\n"
                struct_code += f"    int {var.name}_count; /* Array count */\n"
        
        struct_code += f"}} {context.name};\n"
        
        return struct_code
    
    def _generate_dispatcher_header(self, templates: List[CompiledTemplate], output_dir: Path):
        """Generate cjinja_dispatcher.h for runtime template selection"""
        header_content = '''/*
 * CJinja Template Dispatcher - Generated by CJinja AOT Compiler
 * DO NOT EDIT - This file is automatically generated
 */

#ifndef CJINJA_DISPATCHER_H
#define CJINJA_DISPATCHER_H

#include "cjinja_templates.h"

/**
 * @brief Render template by name with type-safe context
 * @param template_name Name of the template to render
 * @param context Pointer to the template-specific context struct
 * @param buffer Output buffer
 * @param buffer_size Size of output buffer
 * @return Number of bytes written, or -1 on error
 */
static inline int cjinja_render_template(
    const char* template_name,
    const void* context,
    char* buffer,
    size_t buffer_size
) {
    if (!template_name || !context || !buffer || buffer_size == 0) {
        return -1;
    }
    
'''
        
        # Generate dispatch cases
        for template in templates:
            header_content += f'''    if (strcmp(template_name, "{template.name}") == 0) {{
        return render_{template.c_function_name}(
            (const {template.context.name}*)context, buffer, buffer_size
        );
    }}
'''
        
        header_content += '''    
    /* Template not found */
    return -1;
}

/**
 * @brief Get template context size for memory allocation
 * @param template_name Name of the template
 * @return Size in bytes, or 0 if template not found
 */
static inline size_t cjinja_get_context_size(const char* template_name) {
    if (!template_name) {
        return 0;
    }
    
'''
        
        # Generate size cases
        for template in templates:
            header_content += f'''    if (strcmp(template_name, "{template.name}") == 0) {{
        return sizeof({template.context.name});
    }}
'''
        
        header_content += '''    
    return 0;
}

/**
 * @brief List all available compiled templates
 * @return Null-terminated array of template names
 */
static inline const char** cjinja_list_templates(void) {
    static const char* templates[] = {
'''
        
        # Add template names
        for template in templates:
            header_content += f'        "{template.name}",\n'
        
        header_content += '''        NULL
    };
    return templates;
}

#endif /* CJINJA_DISPATCHER_H */
'''
        
        with open(output_dir / "cjinja_dispatcher.h", "w") as f:
            f.write(header_content)
    
    def _generate_context_parser_header(self, templates: List[CompiledTemplate], output_dir: Path):
        """Generate cjinja_context_parser.h for JSON context parsing"""
        header_content = '''/*
 * CJinja Context Parser - Generated by CJinja AOT Compiler
 * DO NOT EDIT - This file is automatically generated
 */

#ifndef CJINJA_CONTEXT_PARSER_H
#define CJINJA_CONTEXT_PARSER_H

#include "cjinja_templates.h"
#include <json-c/json.h>

/**
 * @brief Parse JSON context for a specific template
 * @param template_name Name of the template
 * @param json_str JSON string containing context data
 * @param context Output context structure
 * @return true on success, false on error
 */
static inline bool cjinja_parse_json_context(
    const char* template_name,
    const char* json_str,
    void* context
) {
    if (!template_name || !json_str || !context) {
        return false;
    }
    
    json_object* root = json_tokener_parse(json_str);
    if (!root) {
        return false;
    }
    
    bool success = false;
    
'''
        
        # Generate parsing cases for each template
        for template in templates:
            header_content += f'''    if (strcmp(template_name, "{template.name}") == 0) {{
        {template.context.name}* ctx = ({template.context.name}*)context;
        success = true;
        
'''
            
            # Generate field parsing for each variable
            for var in template.context.variables:
                if var.type == "string":
                    header_content += f'''        json_object* {var.name}_obj;
        if (json_object_object_get_ex(root, "{var.name}", &{var.name}_obj)) {{
            const char* {var.name}_str = json_object_get_string({var.name}_obj);
            strncpy(ctx->{var.name}, {var.name}_str, sizeof(ctx->{var.name}) - 1);
            ctx->{var.name}[sizeof(ctx->{var.name}) - 1] = '\\0';
        }}
        
'''
                elif var.type == "int":
                    header_content += f'''        json_object* {var.name}_obj;
        if (json_object_object_get_ex(root, "{var.name}", &{var.name}_obj)) {{
            ctx->{var.name} = json_object_get_int({var.name}_obj);
        }}
        
'''
                elif var.type == "bool":
                    header_content += f'''        json_object* {var.name}_obj;
        if (json_object_object_get_ex(root, "{var.name}", &{var.name}_obj)) {{
            ctx->{var.name} = json_object_get_boolean({var.name}_obj);
        }}
        
'''
            
            header_content += "    }\n"
        
        header_content += '''    
    json_object_put(root);
    return success;
}

#endif /* CJINJA_CONTEXT_PARSER_H */
'''
        
        with open(output_dir / "cjinja_context_parser.h", "w") as f:
            f.write(header_content)

def main():
    parser = argparse.ArgumentParser(description='CJinja AOT Compiler')
    parser.add_argument('--templates', required=True, 
                       help='Directory containing Jinja2 template files (.j2)')
    parser.add_argument('--output', required=True, 
                       help='Output directory for generated C headers')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Enable verbose output')
    
    args = parser.parse_args()
    
    print("ðŸš€ Starting CJinja AOT Compiler...")
    
    if not HAS_JINJA2:
        print("âš ï¸  Warning: jinja2 library not available, using simplified mode")
    
    # Create output directory
    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Initialize compiler
    compiler = CJinjaAOTCompiler()
    
    # Compile templates
    print("ðŸ“ Compiling Jinja2 templates...")
    templates = compiler.compile_template_directory(Path(args.templates))
    
    if not templates:
        print("âš ï¸  No templates found to compile")
        return 1
    
    # Generate headers
    print("ðŸ”§ Generating C headers...")
    compiler.generate_headers(templates, output_dir)
    
    print(f"âœ… CJinja AOT Compilation Complete!")
    print(f"    ðŸ“ Output directory: {output_dir}")
    print(f"    ðŸ“„ Compiled templates: {len(templates)}")
    
    # Performance summary
    total_complexity = sum(t.complexity_score for t in templates)
    complex_templates = [t for t in templates if t.complexity_score > 20]
    
    print(f"    ðŸ“Š Total complexity score: {total_complexity}")
    if complex_templates:
        print(f"    âš ï¸  Complex templates (>20 score): {[t.name for t in complex_templates]}")
    
    print("\nðŸ“‹ Generated files:")
    print("    - cjinja_templates.h     (compiled template functions)")
    print("    - cjinja_dispatcher.h    (runtime template selection)")
    print("    - cjinja_context_parser.h (JSON context parsing)")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())